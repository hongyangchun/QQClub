# QQClub æƒé™ç³»ç»ŸæŒ‡å—

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç» QQClub é¡¹ç›®çš„ 3 å±‚æƒé™ä½“ç³»ï¼ŒåŒ…æ‹¬è®¾è®¡åŸç†ã€å®ç°æ–¹æ³•ã€æµ‹è¯•å·¥å…·å’Œæœ€ä½³å®è·µã€‚

## ğŸ“‹ ç›®å½•

1. [æƒé™æ¶æ„æ¦‚è§ˆ](#æƒé™æ¶æ„æ¦‚è§ˆ)
2. [è§’è‰²å®šä¹‰](#è§’è‰²å®šä¹‰)
3. [æƒé™å®ç°](#æƒé™å®ç°)
4. [æƒé™æ£€æŸ¥å·¥å…·](#æƒé™æ£€æŸ¥å·¥å…·)
5. [æµ‹è¯•ç”¨ä¾‹](#æµ‹è¯•ç”¨ä¾‹)
6. [å®‰å…¨æœ€ä½³å®è·µ](#å®‰å…¨æœ€ä½³å®è·µ)
7. [æ•…éšœæ’é™¤](#æ•…éšœæ’é™¤)

## æƒé™æ¶æ„æ¦‚è§ˆ

QQClub é‡‡ç”¨ 3 å±‚æƒé™æ¶æ„ï¼Œç¡®ä¿ç³»ç»Ÿå®‰å…¨æ€§å’Œçµæ´»æ€§ï¼š

```
Admin Level (ç®¡ç†å‘˜çº§åˆ«)
â”œâ”€â”€ Root (è¶…çº§ç®¡ç†å‘˜) - ç³»ç»Ÿå¼€å‘è€…
â”œâ”€â”€ Admin (ç®¡ç†å‘˜) - ç¤¾åŒºç®¡ç†è€…
â”‚   â”œâ”€â”€ ç³»ç»Ÿç®¡ç†æƒé™
â”‚   â”œâ”€â”€ ç”¨æˆ·ç®¡ç†æƒé™
â”‚   â””â”€â”€ å†…å®¹å®¡æ ¸æƒé™
â”‚
Event Level (æ´»åŠ¨çº§åˆ«)
â”œâ”€â”€ Group Leader (å°ç»„é•¿) - æ´»åŠ¨åˆ›å»ºè€…
â”œâ”€â”€ Daily Leader (é¢†è¯»äºº) - æ¯æ—¥æ´»åŠ¨è´Ÿè´£äºº
â”‚   â”œâ”€â”€ é¢†è¯»å†…å®¹ç®¡ç†æƒé™
â”‚   â”œâ”€â”€ æ‰“å¡å†…å®¹ç®¡ç†æƒé™
â”‚   â””â”€â”€ å°çº¢èŠ±è¯„é€‰æƒé™
â”‚
User Level (ç”¨æˆ·çº§åˆ«)
â”œâ”€â”€ Forum User (è®ºå›ç”¨æˆ·) - åŸºç¡€æƒé™
â”œâ”€â”€ Participant (æ´»åŠ¨å‚ä¸è€…) - æŠ¥åç”¨æˆ·
â”‚   â”œâ”€â”€ è®ºå›å‘å¸–è¯„è®ºæƒé™
â”‚   â”œâ”€â”€ æ´»åŠ¨æŠ¥åæƒé™
â”‚   â””â”€â”€ ä¸ªäººæ‰“å¡æƒé™
```

## è§’è‰²å®šä¹‰

### Admin Level

#### Root (è¶…çº§ç®¡ç†å‘˜)
- **æƒé™èŒƒå›´**: ç³»ç»Ÿæœ€é«˜æƒé™
- **ä¸»è¦èŒè´£**:
  - ç³»ç»Ÿé…ç½®ç®¡ç†
  - åˆ›å»ºå’Œç®¡ç†ç®¡ç†å‘˜è´¦æˆ·
  - ç³»ç»Ÿçº§å®‰å…¨è®¾ç½®
- **ç‰¹æ®Šæƒé™**:
  - å¯ä»¥åˆ›å»ºå…¶ä»– Root ç”¨æˆ·
  - å¯ä»¥ä¿®æ”¹ç³»ç»Ÿæ ¸å¿ƒé…ç½®
  - æ‹¥æœ‰æ‰€æœ‰æ•°æ®çš„è®¿é—®æƒé™

#### Admin (ç®¡ç†å‘˜)
- **æƒé™èŒƒå›´**: ç¤¾åŒºæ—¥å¸¸ç®¡ç†
- **ä¸»è¦èŒè´£**:
  - æ´»åŠ¨å®¡æ‰¹å’Œç®¡ç†
  - è®ºå›å†…å®¹å®¡æ ¸
  - ç”¨æˆ·è§’è‰²ç®¡ç†ï¼ˆé™¤ Root å¤–ï¼‰
  - ç³»ç»Ÿç»Ÿè®¡æ•°æ®æŸ¥çœ‹

### Event Level

#### Group Leader (å°ç»„é•¿)
- **æƒé™èŒƒå›´**: è‡ªå·±åˆ›å»ºçš„æ´»åŠ¨
- **ä¸»è¦èŒè´£**:
  - æ´»åŠ¨åˆ›å»ºå’Œè®¾ç½®
  - å‚ä¸è€…ç®¡ç†
  - é˜…è¯»è®¡åˆ’åˆ¶å®š
  - å…¨ç¨‹æƒé™å¤‡ä»½
- **æƒé™ç‰¹ç‚¹**:
  - è‡ªåŠ¨è·å¾—æ´»åŠ¨å…¨ç¨‹ç®¡ç†æƒé™
  - å¯ä»¥ä½œä¸º Daily Leader çš„å¤‡ä»½
  - å¯ä»¥è®¾ç½®éšæœºé¢†è¯»å®‰æ’

#### Daily Leader (é¢†è¯»äºº)
- **æƒé™èŒƒå›´**: 3 å¤©æ—¶é—´çª—å£
- **æƒé™çª—å£**:
  - **å‰ä¸€å¤©**: å‘å¸ƒé¢†è¯»å†…å®¹æƒé™
  - **å½“å¤©**: ç®¡ç†æ‰“å¡å’Œäº’åŠ¨æƒé™
  - **åä¸€å¤©**: è¯„é€‰å°çº¢èŠ±æƒé™
- **æƒé™ç‰¹ç‚¹**:
  - åŸºäºæ—¶é—´çš„åŠ¨æ€æƒé™
  - éœ€è¦æƒé™çª—å£éªŒè¯
  - æ”¯æŒå¤‡ä»½æœºåˆ¶

### User Level

#### Forum User (è®ºå›ç”¨æˆ·)
- **æƒé™èŒƒå›´**: åŸºç¡€è®ºå›åŠŸèƒ½
- **ä¸»è¦æƒé™**:
  - å‘å¸ƒå’Œç¼–è¾‘è‡ªå·±çš„å¸–å­
  - è¯„è®ºå’Œäº’åŠ¨
  - æŸ¥çœ‹å…¬å¼€å†…å®¹

#### Participant (æ´»åŠ¨å‚ä¸è€…)
- **æƒé™èŒƒå›´**: æ´»åŠ¨ç›¸å…³åŠŸèƒ½
- **ä¸»è¦æƒé™**:
  - æŠ¥åå‚åŠ æ´»åŠ¨
  - æäº¤ä¸ªäººæ‰“å¡
  - æŸ¥çœ‹æ´»åŠ¨å†…å®¹
  - ç»™ä»–äººé€å°çº¢èŠ±

## æƒé™å®ç°

### 1. æ•°æ®æ¨¡å‹è®¾è®¡

#### User æ¨¡å‹è§’è‰²æšä¸¾
```ruby
class User < ApplicationRecord
  enum :role, {
    user: 0,      # æ™®é€šç”¨æˆ· (Forum User + Participant)
    admin: 1,     # ç®¡ç†å‘˜
    root: 2       # è¶…çº§ç®¡ç†å‘˜
  }

  # ç®¡ç†å‘˜çº§åˆ«æƒé™æ£€æŸ¥
  def any_admin?
    admin? || root?
  end

  def root?
    role == 'root'
  end

  def admin?
    role == 'admin'
  end

  # æ´»åŠ¨æƒé™æ£€æŸ¥
  def can_manage_event_content?(event, schedule)
    return true if any_admin?  # ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™
    return true if event.leader_id == id  # å°ç»„é•¿æƒé™

    # é¢†è¯»äººæƒé™æ£€æŸ¥ï¼ˆ3å¤©çª—å£ï¼‰
    if schedule&.daily_leader_id == id
      permission_window = 1.day  # å¯é…ç½®
      schedule_date = schedule.date

      return true if Date.current >= (schedule_date - permission_window)
      return true if Date.current <= (schedule_date + permission_window)
    end

    false
  end
end
```

### 2. æƒé™éªŒè¯ Concern

#### AdminAuthorizable
```ruby
module AdminAuthorizable
  extend ActiveSupport::Concern

  # ç®¡ç†å‘˜æƒé™éªŒè¯
  def authenticate_admin!
    return render json: { error: "éœ€è¦ç®¡ç†å‘˜æƒé™" }, status: :forbidden unless current_user&.any_admin?
  end

  # è¶…çº§ç®¡ç†å‘˜æƒé™éªŒè¯
  def authenticate_root!
    return render json: { error: "éœ€è¦è¶…çº§ç®¡ç†å‘˜æƒé™" }, status: :forbidden unless current_user&.root?
  end

  # æ´»åŠ¨ç®¡ç†æƒé™éªŒè¯
  def authenticate_event_leader!(event)
    unless current_user&.can_manage_event_content?(event, @schedule)
      render json: { error: "æƒé™ä¸è¶³" }, status: :forbidden
    end
  end
end
```

### 3. æ§åˆ¶å™¨æƒé™ä¿æŠ¤

#### AdminController
```ruby
class AdminController < ApplicationController
  include AdminAuthorizable

  before_action :authenticate_admin!
  before_action :authenticate_root!, only: [:init_root_user]

  # ç®¡ç†å‘˜é¢æ¿
  def dashboard
    render json: {
      total_users: User.count,
      total_events: ReadingEvent.count,
      pending_events: ReadingEvent.where(approval_status: 'pending').count
    }
  end

  # ç”¨æˆ·ç®¡ç†
  def users
    @users = User.all
    render json: @users
  end

  # åˆå§‹åŒ– Root ç”¨æˆ·
  def init_root_user
    # å®ç°é€»è¾‘...
  end
end
```

### 4. è·¯ç”±æƒé™ä¿æŠ¤

```ruby
Rails.application.routes.draw do
  namespace :api do
    # ç®¡ç†å‘˜è·¯ç”±ï¼ˆéœ€è¦æƒé™éªŒè¯ï¼‰
    namespace :admin do
      get "dashboard", to: "admin#dashboard"
      get "users", to: "admin#users"
      post "init_root", to: "admin#init_root_user"
    end

    # å…¬å¼€è·¯ç”±ï¼ˆéœ€è¦ç”¨æˆ·è®¤è¯ï¼‰
    resources :posts do
      member do
        post :pin    # éœ€è¦ç®¡ç†å‘˜æƒé™
        post :hide   # éœ€è¦ç®¡ç†å‘˜æƒé™
      end
    end
  end
end
```

## æƒé™æ£€æŸ¥å·¥å…·

### 1. qq-permissions.sh

å®Œæ•´æƒé™æ£€æŸ¥è„šæœ¬ï¼Œæä¾›å…¨é¢çš„æƒé™ç³»ç»ŸéªŒè¯ï¼š

```bash
# å®Œæ•´æƒé™æ£€æŸ¥
./scripts/qq-permissions.sh

# è¯¦ç»†è°ƒè¯•æ¨¡å¼
./scripts/qq-permissions.sh --debug --verbose

# ä»…æ£€æŸ¥æ¶æ„
./scripts/qq-permissions.sh --check-architecture

# æ£€æŸ¥ç”Ÿäº§ç¯å¢ƒ
./scripts/qq-permissions.sh --api-url https://api.qqclub.com

# ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
./scripts/qq-permissions.sh --report-file custom_report.md
```

**ä¸»è¦åŠŸèƒ½**:
- æƒé™æ¶æ„éªŒè¯
- è§’è‰²æƒé™æµ‹è¯•
- æ—¶é—´çª—å£æƒé™éªŒè¯
- å®‰å…¨æ€§æµ‹è¯•
- å¤‡ä»½æœºåˆ¶æµ‹è¯•
- è‡ªåŠ¨æŠ¥å‘Šç”Ÿæˆ

### 2. permission_analyzer.rb

æ·±åº¦æƒé™åˆ†æå·¥å…·ï¼Œæä¾›é™æ€ä»£ç åˆ†æï¼š

```bash
# è¿è¡Œå®Œæ•´åˆ†æ
./scripts/permission_analyzer.rb

# è¾“å‡ºè¯¦ç»†æŠ¥å‘Š
./scripts/permission_analyzer.rb --output permissions_analysis.json

# æŸ¥çœ‹å¸®åŠ©
./scripts/permission_analyzer.rb --help
```

**ä¸»è¦åŠŸèƒ½**:
- é™æ€ä»£ç åˆ†æ
- æƒé™çŸ©é˜µç”Ÿæˆ
- æµ‹è¯•è¦†ç›–åˆ†æ
- æ•°æ®åº“æƒé™æ£€æŸ¥
- æ”¹è¿›å»ºè®®ç”Ÿæˆ

## æµ‹è¯•ç”¨ä¾‹

### 1. æƒé™æ¶æ„æµ‹è¯•

```ruby
# test/models/user_test.rb
class UserTest < ActiveSupport::TestCase
  test "should validate admin permissions" do
    admin = users(:admin)
    assert admin.any_admin?
    assert_not admin.root?
  end

  test "should validate root permissions" do
    root = users(:root)
    assert root.any_admin?
    assert root.root?
  end

  test "should validate time window permissions" do
    leader = users(:daily_leader)
    event = reading_events(:active_event)
    schedule = event.reading_schedules.today.first

    # æµ‹è¯•æƒé™çª—å£
    assert leader.can_manage_event_content?(event, schedule)
  end
end
```

### 2. æ§åˆ¶å™¨æƒé™æµ‹è¯•

```ruby
# test/controllers/admin_controller_test.rb
class AdminControllerTest < ActionDispatch::IntegrationTest
  test "should require admin authentication" do
    get api_admin_dashboard_url
    assert_response :unauthorized
  end

  test "should allow admin access" do
    admin = users(:admin)
    token = admin.generate_jwt_token

    get api_admin_dashboard_url, headers: {
      'Authorization' => "Bearer #{token}"
    }
    assert_response :success
  end

  test "should deny user access to admin panel" do
    user = users(:regular)
    token = user.generate_jwt_token

    get api_admin_dashboard_url, headers: {
      'Authorization' => "Bearer #{token}"
    }
    assert_response :forbidden
  end
end
```

### 3. é›†æˆæµ‹è¯•

```ruby
# test/integration/permissions_test.rb
class PermissionsTest < ActionDispatch::IntegrationTest
  test "complete permission workflow" do
    # åˆ›å»ºæµ‹è¯•ç”¨æˆ·
    user = create_user(:user)
    admin = create_user(:admin)

    # æµ‹è¯•ç”¨æˆ·æƒé™
    user_token = user.generate_jwt_token
    assert_cannot_access_admin_panel(user_token)

    # æµ‹è¯•ç®¡ç†å‘˜æƒé™
    admin_token = admin.generate_jwt_token
    assert_can_access_admin_panel(admin_token)
  end

  private

  def assert_cannot_access_admin_panel(token)
    get api_admin_dashboard_url, headers: {
      'Authorization' => "Bearer #{token}"
    }
    assert_response :forbidden
  end

  def assert_can_access_admin_panel(token)
    get api_admin_dashboard_url, headers: {
      'Authorization' => "Bearer #{token}"
    }
    assert_response :success
  end
end
```

## å®‰å…¨æœ€ä½³å®è·µ

### 1. æƒé™è®¾è®¡åŸåˆ™

#### æœ€å°æƒé™åŸåˆ™
- æ¯ä¸ªè§’è‰²åªæ‹¥æœ‰å®Œæˆä»»åŠ¡æ‰€éœ€çš„æœ€ä½æƒé™
- é¿å…è¿‡åº¦æˆæƒ
- å®šæœŸå®¡æŸ¥å’Œè°ƒæ•´æƒé™

#### èŒè´£åˆ†ç¦»
- ä¸åŒç±»å‹çš„æƒé™åˆ†ç¦»ç®¡ç†
- å…³é”®æ“ä½œéœ€è¦å¤šé‡éªŒè¯
- é¿å…æƒé™é›†ä¸­

#### å¯å®¡è®¡æ€§
- è®°å½•æ‰€æœ‰æƒé™ç›¸å…³æ“ä½œ
- æä¾›æƒé™å˜æ›´æ—¥å¿—
- æ”¯æŒå®‰å…¨å®¡è®¡

### 2. å®ç°å®‰å…¨æªæ–½

#### Token å®‰å…¨
```ruby
# JWT Token å®‰å…¨é…ç½®
class User < ApplicationRecord
  def generate_jwt_token
    payload = {
      user_id: id,
      role: role,
      exp: 24.hours.from_now.to_i,  # çŸ­æœŸæœ‰æ•ˆæœŸ
      iat: Time.current.to_i         # ç­¾å‘æ—¶é—´
    }

    JWT.encode(payload, Rails.application.credentials.jwt_secret_key)
  end

  def self.decode_jwt_token(token)
    decoded = JWT.decode(
      token,
      Rails.application.credentials.jwt_secret_key,
      true,
      { algorithm: 'HS256' }
    )

    decoded.first
  rescue JWT::ExpiredSignature
    nil  # Token è¿‡æœŸ
  rescue JWT::DecodeError
    nil  # Token æ— æ•ˆ
  end
end
```

#### API å®‰å…¨
```ruby
class ApplicationController < ActionController::API
  include Authenticable

  # é€Ÿç‡é™åˆ¶
  rate_limit = Rails.env.production? ? 100 : 1000

  before_action :check_rate_limit, unless: -> { Rails.env.test? }

  private

  def check_rate_limit
    client_ip = request.remote_ip
    key = "rate_limit:#{client_ip}"

    count = Rails.cache.increment(key, 1, expires_in: 1.hour)

    if count > rate_limit
      render json: { error: "è¯·æ±‚è¿‡äºé¢‘ç¹" }, status: :too_many_requests
    end
  end
end
```

#### æƒé™æ£€æŸ¥åŠ å¼º
```ruby
module AdminAuthorizable
  extend ActiveSupport::Concern

  private

  def authenticate_admin!
    unless current_user&.any_admin?
      log_security_attempt("admin_access_denied")
      render json: { error: "éœ€è¦ç®¡ç†å‘˜æƒé™" }, status: :forbidden
    end
  end

  def log_security_attempt(action)
    Rails.logger.warn "Security attempt: #{action} by user #{current_user&.id} from #{request.remote_ip}"

    # å¯é€‰ï¼šå‘é€å®‰å…¨å‘Šè­¦
    SecurityAlert.notify(action, current_user, request)
  end
end
```

### 3. æ•°æ®åº“å®‰å…¨

#### æ•æ„Ÿæ•°æ®åŠ å¯†
```ruby
class User < ApplicationRecord
  # åŠ å¯†æ•æ„Ÿå­—æ®µ
  has_encrypted :phone, key: Rails.application.credentials.encryption_key

  # å®¡è®¡æ—¥å¿—
  has_many :audit_logs, as: :auditable
end
```

#### æƒé™ç›¸å…³ç´¢å¼•
```ruby
# ä¼˜åŒ–æƒé™æŸ¥è¯¢æ€§èƒ½
add_index :users, :role
add_index :users, :wx_openid, unique: true
add_index :reading_events, [:leader_id, :status]
add_index :reading_schedules, [:reading_event_id, :daily_leader_id]
```

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

#### 1. æƒé™æ£€æŸ¥å¤±è´¥

**é—®é¢˜**: ç”¨æˆ·æ— æ³•è®¿é—®åº”æœ‰çš„èµ„æº

**æ’æŸ¥æ­¥éª¤**:
```bash
# 1. æ£€æŸ¥ç”¨æˆ·è§’è‰²
rails console
> user = User.find_by(wx_openid: "test_user")
> user.role
> user.any_admin?

# 2. æ£€æŸ¥æƒé™æ–¹æ³•
> user.can_manage_event_content?(event, schedule)

# 3. è¿è¡Œæƒé™æ£€æŸ¥å·¥å…·
./scripts/qq-permissions.sh --debug --check-roles
```

**å¯èƒ½åŸå› **:
- ç”¨æˆ·è§’è‰²è®¾ç½®é”™è¯¯
- æƒé™æ–¹æ³•é€»è¾‘é”™è¯¯
- æ—¶é—´çª—å£è®¡ç®—é”™è¯¯

#### 2. Token è®¤è¯é—®é¢˜

**é—®é¢˜**: JWT Token éªŒè¯å¤±è´¥

**æ’æŸ¥æ­¥éª¤**:
```bash
# 1. æ£€æŸ¥ Token ç”Ÿæˆ
rails console
> user = User.first
> token = user.generate_jwt_token
> decoded = User.decode_jwt_token(token)
> puts decoded

# 2. æ£€æŸ¥ Token è¿‡æœŸ
> exp = decoded['exp']
> Time.at(exp) > Time.current

# 3. æ£€æŸ¥å¯†é’¥é…ç½®
> Rails.application.credentials.jwt_secret_key
```

#### 3. æ—¶é—´çª—å£æƒé™é—®é¢˜

**é—®é¢˜**: é¢†è¯»äººæƒé™å¼‚å¸¸

**æ’æŸ¥æ­¥éª¤**:
```bash
# 1. æ£€æŸ¥æƒé™çª—å£è®¡ç®—
rails console
> leader = User.find_by(role: 'user')  # Daily Leader
> schedule = ReadingSchedule.find(date: Date.current)
> leader.can_manage_event_content?(schedule.reading_event, schedule)

# 2. æ£€æŸ¥æ—¥æœŸè®¡ç®—
> schedule_date = schedule.date
> permission_window = 1.day
> Date.current >= (schedule_date - permission_window)
> Date.current <= (schedule_date + permission_window)
```

### è°ƒè¯•æŠ€å·§

#### 1. å¯ç”¨è¯¦ç»†æ—¥å¿—
```ruby
# config/environments/development.rb
config.log_level = :debug
config.logger = Logger.new(STDOUT)
```

#### 2. æƒé™è°ƒè¯•åŠ©æ‰‹
```ruby
# app/controllers/concerns/debuggable_permissions.rb
module DebuggablePermissions
  extend ActiveSupport::Concern

  private

  def debug_permission_check(user, action, resource)
    return unless Rails.env.development?

    Rails.logger.debug "Permission Check:"
    Rails.logger.debug "  User: #{user.id} (#{user.role})"
    Rails.logger.debug "  Action: #{action}"
    Rails.logger.debug "  Resource: #{resource.class.name}##{resource.id}"
    Rails.logger.debug "  Result: #{yield}"
  end
end
```

#### 3. æƒé™å¯è§†åŒ–
```ruby
# lib/permission_visualizer.rb
class PermissionVisualizer
  def self.generate_matrix
    # ç”Ÿæˆæƒé™çŸ©é˜µå¯è§†åŒ–
    # ç”¨äºæƒé™æ–‡æ¡£å’Œè°ƒè¯•
  end
end
```

---

## æ€»ç»“

QQClub æƒé™ç³»ç»Ÿé‡‡ç”¨åˆ†å±‚è®¾è®¡ï¼Œç¡®ä¿å®‰å…¨æ€§å’Œçµæ´»æ€§çš„å¹³è¡¡ã€‚é€šè¿‡å®Œå–„çš„æƒé™æ£€æŸ¥å·¥å…·å’Œæµ‹è¯•è¦†ç›–ï¼Œå¯ä»¥ä¿è¯æƒé™ç³»ç»Ÿçš„å¯é æ€§å’Œå®‰å…¨æ€§ã€‚

**å…³é”®è¦ç‚¹**:
1. ä¸¥æ ¼éµå¾ªæœ€å°æƒé™åŸåˆ™
2. å®šæœŸè¿è¡Œæƒé™æ£€æŸ¥å·¥å…·
3. ä¿æŒé«˜æµ‹è¯•è¦†ç›–ç‡
4. è®°å½•å’Œå®¡è®¡æƒé™æ“ä½œ
5. åŠæ—¶ä¿®å¤æƒé™ç›¸å…³é—®é¢˜

**å·¥å…·ä½¿ç”¨**:
- æ—¥å¸¸æ£€æŸ¥: `./scripts/qq-permissions.sh`
- æ·±åº¦åˆ†æ: `./scripts/permission_analyzer.rb`
- è°ƒè¯•æ¨¡å¼: æ·»åŠ  `--debug --verbose` å‚æ•°

é€šè¿‡éµå¾ªæœ¬æŒ‡å—å’Œå®šæœŸä½¿ç”¨æƒé™æ£€æŸ¥å·¥å…·ï¼Œå¯ä»¥ç¡®ä¿ QQClub é¡¹ç›®çš„æƒé™ç³»ç»Ÿå§‹ç»ˆå®‰å…¨ã€å¯é ã€é«˜æ•ˆè¿è¡Œã€‚