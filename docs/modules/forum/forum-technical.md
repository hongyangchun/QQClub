# QQClub è®ºå›äº¤æµæ¨¡å— - æŠ€æœ¯è®¾è®¡

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

**ç›®æ ‡è¯»è€…**: æŠ€æœ¯è´Ÿè´£äººã€æ¶æ„å¸ˆã€åç«¯å¼€å‘è€…
**æ–‡æ¡£å†…å®¹**: è®ºå›æ¨¡å—çš„ç³»ç»Ÿæ¶æ„ã€æ ¸å¿ƒç®—æ³•ã€æŠ€æœ¯å®ç°ç»†èŠ‚
**ä¸å…¶ä»–æ–‡æ¡£å…³ç³»**: æœ¬æ–‡æ¡£è¯¦ç»†æè¿°æŠ€æœ¯æ¶æ„ï¼Œä¸šåŠ¡é€»è¾‘è¯·å‚è€ƒ [è®ºå›ä¸šåŠ¡è®¾è®¡](forum-business.md)

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  å‰ç«¯å±•ç¤ºå±‚                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Webåº”ç”¨   â”‚  â”‚   ç§»åŠ¨ç«¯    â”‚  â”‚   ç®¡ç†åå°   â”‚  â”‚
â”‚  â”‚   (React)   â”‚  â”‚ (å°ç¨‹åº)    â”‚  â”‚   (Admin)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ HTTP/WebSocket
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 APIç½‘å…³å±‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   è®¤è¯æœåŠ¡   â”‚  â”‚   é™æµæœåŠ¡   â”‚  â”‚   ç›‘æ§æœåŠ¡   â”‚  â”‚
â”‚  â”‚   (JWT)     â”‚  â”‚  (Redis)    â”‚  â”‚ (Metrics)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ å†…éƒ¨APIè°ƒç”¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Ruby on Rails 8 åº”ç”¨å±‚                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                æ§åˆ¶å™¨å±‚ (Controllers)           â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚  â”‚
â”‚  â”‚  â”‚ å¸–å­æ§åˆ¶å™¨â”‚  â”‚ è¯„è®ºæ§åˆ¶å™¨â”‚  â”‚ ç”¨æˆ·æ§åˆ¶å™¨â”‚         â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                æœåŠ¡å±‚ (Services)                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚  â”‚
â”‚  â”‚  â”‚ å†…å®¹æœåŠ¡ â”‚  â”‚ å®¡æ ¸æœåŠ¡ â”‚  â”‚ æ¨èæœåŠ¡ â”‚         â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                æ¨¡å‹å±‚ (Models)                    â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚  â”‚
â”‚  â”‚  â”‚ å¸–å­æ¨¡å‹ â”‚  â”‚ è¯„è®ºæ¨¡å‹ â”‚  â”‚ ç”¨æˆ·æ¨¡å‹ â”‚         â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ æ•°æ®åº“è¿æ¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                æ•°æ®å­˜å‚¨å±‚                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ PostgreSQL  â”‚  â”‚    Redis    â”‚  â”‚   æ–‡ä»¶å­˜å‚¨   â”‚  â”‚
â”‚  â”‚   (ä¸»æ•°æ®)  â”‚  â”‚   (ç¼“å­˜)    â”‚  â”‚   (OSS)     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Elasticsearchâ”‚  â”‚  æ¶ˆæ¯é˜Ÿåˆ—   â”‚  â”‚   ç›‘æ§æ—¥å¿—   â”‚  â”‚
â”‚  â”‚  (æœç´¢)    â”‚  â”‚  (å¼‚æ­¥)    â”‚  â”‚ (Logging)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆé€‰æ‹©

#### åç«¯æŠ€æœ¯æ ˆ
- **æ¡†æ¶**: Ruby on Rails 8
- **æ•°æ®åº“**: PostgreSQL 14+ (ä¸»æ•°æ®åº“)
- **ç¼“å­˜**: Redis 7+ (ç¼“å­˜ + ä¼šè¯å­˜å‚¨)
- **æœç´¢**: Elasticsearch 8+ (å…¨æ–‡æœç´¢)
- **æ¶ˆæ¯é˜Ÿåˆ—**: Sidekiq + Redis (å¼‚æ­¥ä»»åŠ¡)
- **æ–‡ä»¶å­˜å‚¨**: é˜¿é‡Œäº‘OSS (å›¾ç‰‡ã€é™„ä»¶)
- **ç›‘æ§**: Prometheus + Grafana

#### å‰ç«¯æŠ€æœ¯æ ˆ
- **Webç«¯**: React 18 + TypeScript
- **ç§»åŠ¨ç«¯**: å¾®ä¿¡å°ç¨‹åºåŸç”Ÿå¼€å‘
- **ç®¡ç†åå°**: React Admin + Ant Design

---

## ğŸ”§ æ ¸å¿ƒç®—æ³•è®¾è®¡

### 1. å†…å®¹å®¡æ ¸ç®—æ³•

#### æ•æ„Ÿè¯è¿‡æ»¤ç®—æ³•
```ruby
class ContentModerationService
  # æ•æ„Ÿè¯åº“ï¼ˆç¤ºä¾‹ï¼‰
  SENSITIVE_WORDS = %w[
    # æ”¿æ²»æ•æ„Ÿè¯
    # æš´åŠ›è¯æ±‡
    # è¿æ³•å†…å®¹
  ].freeze

  # åŸºäºACè‡ªåŠ¨æœºçš„æ•æ„Ÿè¯æ£€æµ‹
  def self.detect_sensitive_words(content)
    return { score: 0, words: [] } if content.blank?

    ac_machine = build_ac_machine(SENSITIVE_WORDS)
    result = ac_machine.search(content)

    {
      score: calculate_sensitivity_score(result[:words]),
      words: result[:words],
      positions: result[:positions]
    }
  end

  private

  def self.build_ac_machine(words)
    # æ„å»ºACè‡ªåŠ¨æœº
    # å®ç°ç•¥...
  end

  def self.calculate_sensitivity_score(words)
    # æ ¹æ®æ•æ„Ÿè¯ç±»å‹å’Œæ•°é‡è®¡ç®—é£é™©åˆ†æ•°
    words.sum { |word| WORD_WEIGHTS[word] || 1 }
  end
end
```

#### å›¾åƒå†…å®¹è¯†åˆ«
```ruby
class ImageModerationService
  def self.analyze_image(image_url)
    # è°ƒç”¨AIå›¾åƒè¯†åˆ«æœåŠ¡
    result = AiService.analyze_content(image_url)

    {
      safe: result[:safe],
      categories: result[:categories],
      confidence: result[:confidence],
      actions: determine_actions(result)
    }
  end

  private

  def self.determine_actions(analysis_result)
    actions = []

    if analysis_result[:categories].include?('adult')
      actions << :adult_content
    end

    if analysis_result[:categories].include?('violence')
      actions << :violent_content
    end

    actions
  end
end
```

### 2. æ¨èç®—æ³•

#### åŸºäºå†…å®¹çš„æ¨è
```ruby
class ContentRecommendationService
  def self.recommend_for_user(user_id, limit: 10)
    user = User.find(user_id)

    # åŸºäºç”¨æˆ·å…´è¶£æ ‡ç­¾æ¨è
    interest_based_posts = find_posts_by_interests(user.interest_tags, limit / 2)

    # åŸºäºç”¨æˆ·è¡Œä¸ºæ¨è
    behavior_based_posts = find_posts_by_behavior(user, limit / 2)

    # åŸºäºååŒè¿‡æ»¤æ¨è
    collaborative_posts = find_posts_by_collaborative_filtering(user, limit / 2)

    # åˆå¹¶å»é‡å¹¶æ’åº
    merge_and_rank_posts(
      interest_based_posts +
      behavior_based_posts +
      collaborative_posts,
      limit
    )
  end

  private

  def self.find_posts_by_interests(interest_tags, limit)
    return Post.none if interest_tags.blank?

    Post.joins(:tags)
        .where(tags: { name: interest_tags })
        .where('posts.created_at > ?', 1.month.ago)
        .order(interactions_count: :desc)
        .limit(limit)
  end

  def self.find_posts_by_behavior(user, limit)
    # åŸºäºç”¨æˆ·å†å²è¡Œä¸ºï¼ˆç‚¹èµã€è¯„è®ºã€æµè§ˆï¼‰
    interacted_posts = user.interactions.pluck(:post_id)

    # æ‰¾åˆ°ä¸ç”¨æˆ·äº’åŠ¨è¿‡çš„å¸–å­ç›¸ä¼¼çš„å…¶ä»–å¸–å­
    Post.where.not(id: interacted_posts)
        .joins(:tags)
        .where(tags: { id: user.preferred_tag_ids })
        .order(hot_score: :desc)
        .limit(limit)
  end

  def self.merge_and_rank_posts(posts, limit)
    posts.uniq.sort_by { |post| -post.calculate_recommendation_score }.first(limit)
  end
end
```

### 3. çƒ­åº¦è®¡ç®—ç®—æ³•

```ruby
class HotScoreCalculator
  # ç±»ä¼¼Redditçš„çƒ­åº¦ç®—æ³•
  def self.calculate_score(post)
    return 0 if post.nil?

    # åŸºç¡€å‚æ•°
    upvotes = post.likes_count
    downvotes = post.dislikes_count || 0
    comments = post.comments_count
    time_diff = Time.current - post.created_at

    # çƒ­åº¦è®¡ç®—
    score = calculate_hot_score(upvotes, downvotes, comments, time_diff)

    # æ›´æ–°å¸–å­çƒ­åº¦åˆ†æ•°
    post.update_column(:hot_score, score)

    score
  end

  private

  def self.calculate_hot_score(upvotes, downvotes, comments, time_diff)
    # åŸºç¡€åˆ†æ•°
    score = upvotes - downvotes

    # è¯„è®ºæƒé‡
    score += comments * 0.5

    # æ—¶é—´è¡°å‡
    time_factor = 1 / (time_diff.to_f / 3600 + 2) ** 1.5

    # çƒ­åº¦åˆ†æ•°
    (score * time_factor).round(2)
  end
end
```

### 4. å†…å®¹è´¨é‡è¯„ä¼°ç®—æ³•

```ruby
class ContentQualityService
  def self.assess_post_quality(post)
    factors = {
      length_factor: calculate_length_factor(post),
      engagement_factor: calculate_engagement_factor(post),
      originality_factor: calculate_originality_factor(post),
      format_factor: calculate_format_factor(post)
    }

    quality_score = factors.values.sum / factors.size

    {
      score: quality_score.round(2),
      level: determine_quality_level(quality_score),
      factors: factors
    }
  end

  private

  def self.calculate_length_factor(post)
    content_length = post.content.length

    case content_length
    when 0..50
      0.2
    when 51..200
      0.6
    when 201..800
      1.0
    when 801..2000
      0.9
    else
      0.7
    end
  end

  def self.calculate_engagement_factor(post)
    return 0 if post.views_count == 0

    engagement_rate = (post.likes_count + post.comments_count).to_f / post.views_count

    case engagement_rate
    when 0..0.01
      0.2
    when 0.01..0.05
      0.6
    when 0.05..0.15
      1.0
    else
      0.8
    end
  end

  def self.determine_quality_level(score)
    case score
    when 0..0.3
      :low
    when 0.3..0.7
      :medium
    else
      :high
    end
  end
end
```

---

## ğŸ›¡ï¸ å®‰å…¨è®¾è®¡

### 1. è®¤è¯ä¸æˆæƒ

#### JWT Token ç®¡ç†
```ruby
class AuthenticationService
  JWT_SECRET = Rails.application.credentials.jwt_secret_key
  TOKEN_EXPIRATION = 7.days

  def self.generate_token(user)
    payload = {
      user_id: user.id,
      role: user.role,
      exp: TOKEN_EXPIRATION.from_now.to_i,
      iat: Time.current.to_i,
      jti: SecureRandom.uuid
    }

    JWT.encode(payload, JWT_SECRET, 'HS256')
  end

  def self.verify_token(token)
    decoded = JWT.decode(token, JWT_SECRET, true, algorithm: 'HS256').first

    # æ£€æŸ¥tokenæ˜¯å¦åœ¨é»‘åå•ä¸­
    return nil if TokenBlacklist.exists?(jti: decoded['jti'])

    decoded
  rescue JWT::DecodeError, JWT::ExpiredSignature
    nil
  end

  def self.blacklist_token(token)
    decoded = JWT.decode(token, JWT_SECRET, true, algorithm: 'HS256').first
    TokenBlacklist.create!(
      jti: decoded['jti'],
      expires_at: Time.at(decoded['exp'])
    )
  end
end
```

#### æƒé™æ£€æŸ¥ä¸­é—´ä»¶
```ruby
class ForumAuthorizer
  def self.can_create_post?(user)
    return false unless user.present?
    return false unless user.verified?

    # æ–°ç”¨æˆ·é™åˆ¶
    return false if user.new_user?

    true
  end

  def self.can_moderate_content?(user, content)
    return false unless user.present?

    # ç³»ç»Ÿç®¡ç†å‘˜å¯ä»¥ç®¡ç†æ‰€æœ‰å†…å®¹
    return true if user.system_admin?

    # ç¤¾åŒºç®¡ç†å‘˜å¯ä»¥ç®¡ç†æ‰€æœ‰å†…å®¹
    return true if user.community_manager?

    # ç‰ˆä¸»åªèƒ½ç®¡ç†è‡ªå·±ç‰ˆå—çš„å†…å®¹
    return true if user.moderator? &&
                     user.moderated_categories.include?(content.category)

    false
  end

  def self.can_edit_content?(user, content)
    return false unless user.present?

    # ä½œè€…å¯ä»¥ç¼–è¾‘è‡ªå·±çš„å†…å®¹
    return true if content.user_id == user.id

    # ç®¡ç†å‘˜å¯ä»¥ç¼–è¾‘æ‰€æœ‰å†…å®¹
    return true if user.any_admin?

    false
  end
end
```

### 2. æ•°æ®éªŒè¯ä¸é˜²æŠ¤

#### è¾“å…¥éªŒè¯
```ruby
class Post < ApplicationRecord
  include ActionView::Helpers::SanitizeHelper

  validates :title, presence: true, length: { minimum: 5, maximum: 100 }
  validates :content, presence: true, length: { minimum: 10, maximum: 10000 }
  validates :category_id, presence: true

  # è‡ªå®šä¹‰éªŒè¯
  validate :validate_content_safety
  validate :validate_rate_limit

  private

  def validate_content_safety
    # XSSé˜²æŠ¤
    sanitized_content = sanitize(content)

    if sanitized_content != content
      errors.add(:content, "åŒ…å«ä¸å®‰å…¨çš„å†…å®¹")
    end

    # æ•æ„Ÿè¯æ£€æµ‹
    moderation_result = ContentModerationService.detect_sensitive_words(content)
    if moderation_result[:score] > 80
      errors.add(:content, "åŒ…å«æ•æ„Ÿå†…å®¹ï¼Œè¯·ä¿®æ”¹åé‡è¯•")
    end
  end

  def validate_rate_limit
    # é˜²åˆ·æœºåˆ¶
    recent_posts = user.posts.where('created_at > ?', 5.minutes.ago)
    if recent_posts.count >= 3
      errors.add(:base, "å‘å¸–è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•")
    end
  end
end
```

#### SQLæ³¨å…¥é˜²æŠ¤
```ruby
class SearchService
  def self.search_posts(query, options = {})
    return Post.none if query.blank?

    # ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
    posts = Post.joins(:user, :category)
                 .where("posts.title ILIKE :query OR posts.content ILIKE :query",
                        query: "%#{sanitize_sql_like(query)}%")

    # åº”ç”¨è¿‡æ»¤æ¡ä»¶
    posts = posts.where(category_id: options[:category_id]) if options[:category_id].present?
    posts = posts.where("posts.created_at > ?", options[:created_after]) if options[:created_after].present?

    # æ’åº
    posts = case options[:sort]
            when 'hot'
              posts.order(hot_score: :desc)
            when 'new'
              posts.order(created_at: :desc)
            else
              posts.order(interactions_count: :desc)
            end

    posts
  end

  private

  def self.sanitize_sql_like(query)
    # è½¬ä¹‰SQL LIKEä¸­çš„ç‰¹æ®Šå­—ç¬¦
    query.gsub(/[%_\\]/) { |char| "\\#{char}" }
  end
end
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. æ•°æ®åº“ä¼˜åŒ–

#### ç´¢å¼•ç­–ç•¥
```sql
-- å¸–å­è¡¨ç´¢å¼•
CREATE INDEX idx_posts_category_id ON posts(category_id);
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_status ON posts(status);
CREATE INDEX idx_posts_created_at ON posts(created_at DESC);
CREATE INDEX idx_posts_hot_score ON posts(hot_score DESC);

-- å¤åˆç´¢å¼•
CREATE INDEX idx_posts_category_status ON posts(category_id, status);
CREATE INDEX idx_posts_user_created ON posts(user_id, created_at DESC);

-- è¯„è®ºè¡¨ç´¢å¼•
CREATE INDEX idx_comments_post_id ON comments(post_id);
CREATE INDEX idx_comments_user_id ON comments(user_id);
CREATE INDEX idx_comments_created_at ON comments(created_at DESC);

-- ç‚¹èµè¡¨ç´¢å¼•
CREATE INDEX idx_likes_target ON likes(likeable_type, likeable_id);
CREATE INDEX idx_likes_user ON likes(user_id, created_at DESC);
```

#### æŸ¥è¯¢ä¼˜åŒ–
```ruby
class Post < ApplicationRecord
  # é¢„åŠ è½½å…³è”ï¼Œé¿å…N+1æŸ¥è¯¢
  scope :with_details, -> { includes(:user, :category, :tags, :rich_content) }

  # åˆ†é¡µä¼˜åŒ–
  scope :paginated, -> (page, per_page = 20) {
    limit(per_page).offset((page - 1) * per_page)
  }

  # çƒ­é—¨å¸–å­æŸ¥è¯¢ä¼˜åŒ–
  scope :hot_posts, -> {
    where(status: :published)
      .where('posts.created_at > ?', 7.days.ago)
      .order(hot_score: :desc)
      .includes(:user, :category)
  }

  def self.search_with_filters(params)
    posts = all

    # æ–‡æœ¬æœç´¢ï¼ˆä½¿ç”¨å…¨æ–‡æœç´¢ç´¢å¼•ï¼‰
    if params[:q].present?
      posts = posts.where("search_vector @@ websearch(to_tsquery('simple', ?))", params[:q])
    end

    # åˆ†ç±»è¿‡æ»¤
    if params[:category_id].present?
      posts = posts.where(category_id: params[:category_id])
    end

    # æ—¶é—´è¿‡æ»¤
    if params[:time_range].present?
      time_range = case params[:time_range]
                  when 'day'
                    1.day.ago
                  when 'week'
                    1.week.ago
                  when 'month'
                    1.month.ago
                  else
                    1.year.ago
                  end
      posts = posts.where('posts.created_at > ?', time_range)
    end

    posts
  end
end
```

### 2. ç¼“å­˜ç­–ç•¥

#### å¤šå±‚ç¼“å­˜è®¾è®¡
```ruby
class ForumCache
  # L1ç¼“å­˜ï¼šåº”ç”¨å†…å­˜ç¼“å­˜ï¼ˆæœ€çƒ­æ•°æ®ï¼‰
  def self.get_hot_categories
    @hot_categories ||= Rails.cache.fetch('forum:hot_categories', expires_in: 1.hour) do
      Category.where.not(posts_count: 0)
              .order(posts_count: :desc)
              .limit(10)
              .to_a
    end
  end

  # L2ç¼“å­˜ï¼šRedisç¼“å­˜ï¼ˆçƒ­ç‚¹æ•°æ®ï¼‰
  def self.get_post_stats(post_id)
    Rails.cache.fetch("forum:post_stats:#{post_id}", expires_in: 10.minutes) do
      post = Post.find(post_id)

      {
        views_count: post.views_count,
        likes_count: post.likes_count,
        comments_count: post.comments_count,
        shares_count: post.shares_count,
        hot_score: post.hot_score
      }
    end
  end

  # L3ç¼“å­˜ï¼šæ•°æ®åº“æŸ¥è¯¢ç»“æœç¼“å­˜
  def self.get_user_feed(user_id, page = 1)
    cache_key = "forum:user_feed:#{user_id}:page:#{page}"

    Rails.cache.fetch(cache_key, expires_in: 5.minutes) do
      user = User.find(user_id)

      # ä¸ªæ€§åŒ–æ¨èé€»è¾‘
      recommended_posts = ContentRecommendationService
                           .recommend_for_user(user_id, limit: 20)

      # æŒ‰é¡µåˆ†å‰²
      recommended_posts.paginated(page, 10)
    end
  end

  # ç¼“å­˜å¤±æ•ˆç­–ç•¥
  def self.invalidate_post_cache(post_id)
    Rails.cache.delete("forum:post_stats:#{post_id}")

    # ä½¿ç›¸å…³ç”¨æˆ·çš„Feedç¼“å­˜å¤±æ•ˆ
    post.interactions.pluck(:user_id).each do |user_id|
      (1..5).each do |page|
        Rails.cache.delete("forum:user_feed:#{user_id}:page:#{page}")
      end
    end
  end
end
```

### 3. å¼‚æ­¥å¤„ç†

#### é˜Ÿåˆ—ä»»åŠ¡è®¾è®¡
```ruby
# å¼‚æ­¥å†…å®¹å®¡æ ¸
class ContentModerationJob < ApplicationJob
  queue_as :moderation

  def perform(content_id, content_type)
    content = content_type.constantize.find(content_id)

    # è‡ªåŠ¨å®¡æ ¸
    auto_result = ContentModerationService.auto_moderate(content)

    if auto_result[:safe]
      content.update!(status: :published)
    else
      # è¿›å…¥äººå·¥å®¡æ ¸é˜Ÿåˆ—
      content.update!(status: :pending_review)
      ManualReviewJob.perform_later(content_id, content_type)
    end

    # æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
    UpdateUserStatsJob.perform_later(content.user_id)
  end
end

# å¼‚æ­¥çƒ­åº¦è®¡ç®—
class HotScoreCalculationJob < ApplicationJob
  queue_as :scoring

  def perform
    # è®¡ç®—æ‰€æœ‰å¸–å­çš„çƒ­åº¦åˆ†æ•°
    Post.find_in_batches(batch_size: 100) do |posts|
      posts.each do |post|
        score = HotScoreCalculator.calculate_score(post)

        # æ›´æ–°çƒ­é—¨æ’è¡Œ
        if score_changed_significantly?(post, score)
          UpdateHotRankingJob.perform_later(post)
        end
      end
    end
  end

  private

  def self.score_changed_significantly?(post, new_score)
    old_score = post.hot_score || 0
    (new_score - old_score).abs > 10
  end
end

# æ¨èè®¡ç®—ä»»åŠ¡
class RecommendationCalculationJob < ApplicationJob
  queue_as :recommendation

  def perform(user_id)
    # é‡æ–°è®¡ç®—ç”¨æˆ·æ¨è
    user = User.find(user_id)

    # é¢„è®¡ç®—æ¨èç»“æœå¹¶ç¼“å­˜
    recommendations = ContentRecommendationService
                       .recommend_for_user(user_id, limit: 50)

    Rails.cache.write(
      "forum:user_recommendations:#{user_id}",
      recommendations,
      expires_in: 1.hour
    )
  end
end
```

---

## ğŸ“ˆ ç›‘æ§ä¸æ—¥å¿—

### 1. åº”ç”¨ç›‘æ§

#### å…³é”®æŒ‡æ ‡ç›‘æ§
```ruby
class ForumMetrics
  # å†…å®¹åˆ›å»ºç›‘æ§
  def self.track_content_creation(content)
    Rails.logger.info "Content created: #{content.class.name}##{content.id} by User##{content.user_id}"

    # å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    StatsD.increment('forum.content.created', tags: [
      "type:#{content.class.name.downcase}",
      "category:#{content.category&.name || 'none'}"
    ])

    # è®°å½•å†…å®¹è´¨é‡
    quality = ContentQualityService.assess_post_quality(content)
    StatsD.histogram('forum.content.quality', quality[:score])
  end

  # ç”¨æˆ·è¡Œä¸ºç›‘æ§
  def self.track_user_interaction(user, action, target)
    Rails.logger.info "User interaction: #{user.id} #{action} #{target.class.name}##{target.id}"

    StatsD.increment('forum.user.interaction', tags: [
      "action:#{action}",
      "target:#{target.class.name.downcase}"
    ])
  end

  # ç³»ç»Ÿæ€§èƒ½ç›‘æ§
  def self.track_request_performance(controller, action, duration)
    StatsD.timing('forum.request.duration', duration, tags: [
      "controller:#{controller}",
      "action:#{action}"
    ])

    if duration > 1.second
      Rails.logger.warn "Slow request: #{controller}##{action} took #{duration}s"
    end
  end
end
```

#### å¼‚å¸¸ç›‘æ§
```ruby
class ForumErrorHandler
  def self.handle_error(exception, context = {})
    # è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯
    Rails.logger.error "Forum Error: #{exception.message}"
    Rails.logger.error exception.backtrace.join("\n")
    Rails.logger.error "Context: #{context}"

    # å‘é€åˆ°é”™è¯¯ç›‘æ§æœåŠ¡
    if Rails.env.production?
      Raven.capture_exception(exception, {
        extra: context,
        tags: { component: 'forum' }
      })
    end

    # æ ¹æ®é”™è¯¯ç±»å‹è¿›è¡Œç‰¹æ®Šå¤„ç†
    case exception
    when ActiveRecord::RecordNotFound
      handle_not_found_error(exception, context)
    when ActionController::ParameterMissing
      handle_parameter_error(exception, context)
    when StandardError
      handle_standard_error(exception, context)
    else
      handle_unknown_error(exception, context)
    end
  end

  private

  def self.handle_not_found_error(exception, context)
    Rails.logger.warn "Not found error in #{context[:controller]}##{context[:action]}"
  end

  def self.handle_parameter_error(exception, context)
    Rails.logger.warn "Parameter error in #{context[:controller]}##{context[:action]}: #{exception.message}"
  end
end
```

### 2. æ—¥å¿—ç®¡ç†

#### ç»“æ„åŒ–æ—¥å¿—
```ruby
class ForumLogger
  def self.log_user_action(action, user, details = {})
    log_entry = {
      timestamp: Time.current.iso8601,
      level: 'info',
      service: 'forum',
      action: action,
      user_id: user&.id,
      details: details,
      request_id: Current.request_id
    }

    Rails.logger.info(log_entry.to_json)
  end

  def self.log_moderation_action(action, moderator, target, reason = nil)
    log_entry = {
      timestamp: Time.current.iso8601,
      level: 'info',
      service: 'forum',
      action: "moderation_#{action}",
      moderator_id: moderator&.id,
      target_type: target&.class&.name,
      target_id: target&.id,
      reason: reason,
      request_id: Current.request_id
    }

    Rails.logger.info(log_entry.to_json)
  end

  def self.log_system_event(event, details = {})
    log_entry = {
      timestamp: Time.current.iso8601,
      level: 'info',
      service: 'forum',
      event: event,
      details: details,
      request_id: Current.request_id
    }

    Rails.logger.info(log_entry.to_json)
  end
end
```

---

## ğŸ”„ APIè®¾è®¡åŸåˆ™

### 1. RESTful APIè®¾è®¡

#### èµ„æºè·¯ç”±
```ruby
# config/routes.rb
Rails.application.routes.draw do
  namespace :api do
    namespace :v1 do
      resources :categories, only: [:index, :show]
      resources :posts, except: [:new, :edit] do
        member do
          post :like
          delete :unlike
          post :report
          post :share
        end

        resources :comments, only: [:index, :create, :update, :destroy] do
          member do
            post :like
            delete :unlike
            post :report
          end
        end
      end

      resources :users, only: [:show] do
        member do
          get :posts
          get :comments
          get :followers
          get :following
        end
      end

      # ç®¡ç†å‘˜è·¯ç”±
      namespace :admin do
        resources :posts, only: [:index, :update, :destroy] do
          member do
            post :approve
            post :reject
            post :pin
            post :unpin
          end
        end

        resources :categories, except: [:show] do
          member do
            post :assign_moderator
            delete :remove_moderator
          end
        end

        resources :reports, only: [:index, :show, :update]
      end
    end
  end
end
```

### 2. ç»Ÿä¸€å“åº”æ ¼å¼

#### æˆåŠŸå“åº”
```ruby
class Api::V1::BaseController < ActionController::API
  private

  def render_success(data: nil, message: 'æ“ä½œæˆåŠŸ', meta: {})
    render json: {
      success: true,
      message: message,
      data: data,
      meta: meta
    }
  end

  def render_error(message: 'æ“ä½œå¤±è´¥', errors: [], status: :unprocessable_entity)
    render json: {
      success: false,
      message: message,
      errors: errors
    }, status: status
  end

  def render_pagination(collection, serializer_options = {})
    render(
      json: {
        success: true,
        data: collection.map { |item| serializer_class.new(item).as_json(serializer_options) },
        pagination: {
          current_page: collection.current_page,
          total_pages: collection.total_pages,
          total_count: collection.total_count,
          per_page: collection.limit_value
        }
      }
    )
  end
end
```

---

## ğŸš€ éƒ¨ç½²æ¶æ„

### Dockerå®¹å™¨åŒ–
```dockerfile
# Dockerfile.forum
FROM ruby:3.1-alpine

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apk add --no-cache build-base postgresql-dev nodejs npm

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY Gemfile Gemfile.lock ./
RUN bundle config set --local deployment 'true' && bundle install --without development test

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# é¢„ç¼–è¯‘èµ„äº§
RUN SECRET_KEY_BASE_DUMMY=1 RAILS_ENV=production bundle exec rails assets:precompile

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV RAILS_ENV=production
ENV RAILS_LOG_TO_STDOUT=true
ENV RAILS_SERVE_STATIC_FILES=true

# å¯åŠ¨åº”ç”¨
EXPOSE 3000
CMD ["bundle", "exec", "puma", "-C", "config/puma.rb"]
```

### æœåŠ¡ç¼–æ’
```yaml
# docker-compose.forum.yml
version: '3.8'

services:
  forum-app:
    build: .
    ports:
      - "3001:3000"
    environment:
      - RAILS_ENV=production
      - DATABASE_URL=postgresql://postgres:password@db:5432/forum_production
      - REDIS_URL=redis://redis:6379/1
      - ELASTICSEARCH_URL=http://elasticsearch:9200
    depends_on:
      - db
      - redis
      - elasticsearch
    volumes:
      - ./log:/app/log
      - ./public/system:/app/public/system

  db:
    image: postgres:14
    environment:
      POSTGRES_DB: forum_production
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.5.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data

volumes:
  postgres_data:
  redis_data:
  elasticsearch_data:
```

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

### è®ºå›æ¨¡å—å†…éƒ¨æ–‡æ¡£
- **[è®ºå›æ€»è§ˆ](forum-overview.md)** - æ¨¡å—æ•´ä½“ä»‹ç»
- **[è®ºå›ä¸šåŠ¡è®¾è®¡](forum-business.md)** - ä¸šåŠ¡æµç¨‹å’Œç”¨æˆ·è§’è‰²
- **[è®ºå›ç”¨æˆ·ä½“éªŒè®¾è®¡](forum-ux.md)** - ç•Œé¢å’Œäº¤äº’è®¾è®¡
- **[è®ºå›APIè§„èŒƒ](forum-api.md)** - APIæ¥å£æ–‡æ¡£
- **[è®ºå›æ•°æ®åº“è®¾è®¡](forum-database.md)** - æ•°æ®æ¨¡å‹è®¾è®¡
- **[è®ºå›å®æ–½æŒ‡å—](forum-implementation.md)** - å¼€å‘å’Œéƒ¨ç½²æŒ‡å—

### å…¶ä»–æ¨¡å—æ–‡æ¡£
- **[å…±è¯»æ´»åŠ¨æ¨¡å—](../reading-event/reading-event-technical.md)** - å…±è¯»æ´»åŠ¨æŠ€æœ¯è®¾è®¡
- **[ç³»ç»Ÿæ¶æ„è®¾è®¡](../../technical/ARCHITECTURE.md)** - æ•´ä½“æŠ€æœ¯æ¶æ„

---

*æœ¬æ–‡æ¡£æœ€åæ›´æ–°: 2025-10-17*