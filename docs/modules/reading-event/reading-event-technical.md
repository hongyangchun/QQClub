# QQClub å…±è¯»æ´»åŠ¨æ¨¡å— - æŠ€æœ¯è®¾è®¡

## ğŸ“‹ æ–‡æ¡£è¯´æ˜

**ç›®æ ‡è¯»è€…**: æŠ€æœ¯è´Ÿè´£äººã€æ¶æ„å¸ˆã€åç«¯å¼€å‘è€…
**æ–‡æ¡£å†…å®¹**: ç³»ç»Ÿæ¶æ„ã€æ ¸å¿ƒç®—æ³•ã€æŠ€æœ¯å®ç°ç»†èŠ‚

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ•´ä½“æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         å¾®ä¿¡å°ç¨‹åºå‰ç«¯                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  æ´»åŠ¨é¡µé¢â”‚  â”‚  ç”¨æˆ·é¡µé¢â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ APIè°ƒç”¨
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Ruby on Rails 8 åç«¯          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ APIæ§åˆ¶å™¨â”‚  â”‚ ä¸šåŠ¡æœåŠ¡ â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ æ•°æ®è®¿é—®
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        SQLite/PostgreSQL æ•°æ®åº“       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  æ´»åŠ¨è¡¨  â”‚  â”‚  ç”¨æˆ·è¡¨  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆ
- **å‰ç«¯**: å¾®ä¿¡å°ç¨‹åºåŸç”Ÿå¼€å‘
- **åç«¯**: Ruby on Rails 8
- **æ•°æ®åº“**: SQLite (å¼€å‘) / PostgreSQL (ç”Ÿäº§)
- **è®¤è¯**: JWT Token
- **ç¼“å­˜**: Redis (å¯é€‰)
- **éƒ¨ç½²**: Docker + äº‘æœåŠ¡

### æ ¸å¿ƒè®¾è®¡æ¨¡å¼

#### 1. ç­–ç•¥æ¨¡å¼ - æ´»åŠ¨æ¨¡å¼
```ruby
class ActivityMode
  def initialize(event)
    @event = event
  end

  def calculate_completion_rate(user)
    raise NotImplementedError
  end
end

class NoteCheckinMode < ActivityMode
  def calculate_completion_rate(user)
    # ç¬”è®°æ‰“å¡æ¨¡å¼ç®—æ³•
  end
end
```

#### 2. çŠ¶æ€æœºæ¨¡å¼ - æ´»åŠ¨çŠ¶æ€
```ruby
class ReadingEvent < ApplicationRecord
  enum :status, { draft: 0, enrolling: 1, in_progress: 2, completed: 3 }

  def start!
    update!(status: :in_progress) if can_start?
  end

  def complete!
    update!(status: :completed) if can_complete?
  end
end
```

#### 3. è§‚å¯Ÿè€…æ¨¡å¼ - çŠ¶æ€é€šçŸ¥
```ruby
class EventObserver
  def self.notify(event, action, data = {})
    # å‘é€é€šçŸ¥é€»è¾‘
  end
end
```

---

## ğŸ”§ æ ¸å¿ƒç®—æ³•è®¾è®¡

### 1. éšæœºé¢†è¯»ç®—æ³•

#### æƒé‡åˆ†é…ç®—æ³•
```ruby
class LeaderAssignmentService
  def self.assign_daily_leader(event, schedule)
    participants = event.participants.active

    # æ’é™¤æœ€è¿‘3å¤©å·²æ‹…ä»»é¢†è¯»çš„ç”¨æˆ·
    recent_leaders = get_recent_leaders(event, 3)
    available_participants = participants - recent_leaders

    # å¦‚æœæ’é™¤åæ— äººå¯é€‰ï¼Œåˆ™ä»å…¨éƒ¨å‚ä¸è€…ä¸­é€‰æ‹©
    available_participants = participants if available_participants.empty?

    # åŸºäºæƒé‡çš„éšæœºé€‰æ‹©
    selected_leader = weighted_random_selection(available_participants)

    # è®°å½•åˆ†é…ç»“æœ
    create_daily_leading_assignment(event, schedule, selected_leader)

    # å‘é€é€šçŸ¥
    notify_leader_assignment(selected_leader, schedule)

    selected_leader
  end

  private

  def self.weighted_random_selection(participants)
    # åŸºäºå†å²é¢†è¯»æ¬¡æ•°çš„æƒé‡ç®—æ³•
    # é¢†è¯»æ¬¡æ•°è¶Šå°‘ï¼Œè¢«é€‰ä¸­æ¦‚ç‡è¶Šé«˜
    weights = participants.map do |participant|
      leader_count = participant.leading_assignments.count
      [participant, 1.0 / (leader_count + 1)]
    end

    total_weight = weights.sum { |_, weight| weight }
    random_value = rand * total_weight

    current_weight = 0
    weights.each do |participant, weight|
      current_weight += weight
      return participant if current_weight >= random_value
    end

    participants.last
  end
end
```

### 2. å®Œæˆç‡è®¡ç®—ç®—æ³•

#### é€šç”¨è®¡ç®—å™¨
```ruby
class CompletionRateCalculator
  def self.calculate_for_user(user, event)
    case event.activity_mode
    when 'note_checkin'
      calculate_note_checkin_completion(user, event)
    when 'free_discussion'
      calculate_free_discussion_completion(user, event)
    when 'video_conference'
      calculate_video_conference_completion(user, event)
    when 'offline_meeting'
      calculate_offline_meeting_completion(user, event)
    else
      0.0
    end
  end

  private

  def self.calculate_note_checkin_completion(user, event)
    schedules = event.reading_schedules
    total_days = calculate_total_reading_days(schedules, event)

    return 0.0 if total_days == 0

    # è·å–å®é™…æ‰“å¡æ¬¡æ•°
    check_ins_count = user.check_ins
      .where(schedule: schedules)
      .where.not(status: 'supplement')
      .count

    # è·å–æ‹…ä»»é¢†è¯»å¤©æ•°
    leader_days_count = user.daily_leading_assignments
      .where(reading_schedule: schedules)
      .count

    # è®¡ç®—å®Œæˆç‡ï¼š(æ‰“å¡æ¬¡æ•° + æ‹…ä»»é¢†è¯»å¤©æ•°) / æ€»å¤©æ•°
    completed_days = check_ins_count + leader_days_count
    (completed_days.to_f / total_days * 100).round(2)
  end
end
```

### 3. è´¹ç”¨ç»“ç®—ç®—æ³•

#### æŠ¼é‡‘é€€è¿˜è®¡ç®—
```ruby
class DepositRefundCalculator
  def self.calculate_refund_amount(user, event)
    return 0.0 if event.fee_type != 'deposit'

    completion_rate = CompletionRateCalculator.calculate_for_user(user, event)
    completion_standard = event.completion_standard || 80
    fee_amount = event.fee_amount || 0.0
    leader_reward_percentage = event.leader_reward_percentage || 20.0

    # è®¡ç®—æŠ¼é‡‘æ± é‡‘é¢ (æ€»è´¹ç”¨ - å°ç»„é•¿æŠ¥é…¬)
    leader_reward = fee_amount * (leader_reward_percentage / 100.0)
    deposit_pool = fee_amount - leader_reward

    # åŸºäºæ´»åŠ¨è®¾å®šçš„å®Œæˆç‡æ ‡å‡†è®¡ç®—é€€è¿˜æ¯”ä¾‹
    refund_percentage = calculate_refund_percentage(completion_rate, completion_standard)
    (deposit_pool * refund_percentage).round(2)
  end

  def self.calculate_refund_percentage(completion_rate, completion_standard)
    # å…¨é¢é€€è¿˜æŠ¼é‡‘æ± ï¼šè¾¾åˆ°æˆ–è¶…è¿‡è®¾å®šçš„å®Œæˆç‡æ ‡å‡†
    return 1.0 if completion_rate >= completion_standard

    # ä¸é€€è¿˜æŠ¼é‡‘æ± ï¼šå®Œæˆç‡ä½äºæ ‡å‡†
    return 0.0
  end

  def self.calculate_leader_reward(event)
    return 0.0 if event.fee_type == 'free'

    fee_amount = event.fee_amount || 0.0
    leader_reward_percentage = event.leader_reward_percentage || 20.0

    if event.fee_type == 'deposit'
      # æŠ¼é‡‘åˆ¶ï¼šæŒ‰æ¯”ä¾‹è®¡ç®—å°ç»„é•¿æŠ¥é…¬
      (fee_amount * leader_reward_percentage / 100.0).round(2)
    elsif event.fee_type == 'paid'
      # æ”¶è´¹åˆ¶ï¼šå…¨éƒ¨è´¹ç”¨ä½œä¸ºå°ç»„é•¿æŠ¥é…¬
      fee_amount
    else
      0.0
    end
  end
end
```

---

## ğŸ” å®‰å…¨è®¾è®¡

### 1. è®¤è¯æœºåˆ¶
```ruby
class AuthenticationController < ApplicationController
  def authenticate_user!
    token = request.headers['Authorization']&.split(' ')&.last
    @current_user = User.find_by(auth_token: token)

    render json: { error: 'Unauthorized' }, status: :unauthorized unless @current_user
  end

  def authorize_leader!
    return render json: { error: 'Forbidden' }, status: :forbidden unless @current_user.leader?
  end
end
```

### 2. æƒé™æ£€æŸ¥
```ruby
class AuthorizationService
  def self.can_manage_event?(user, event)
    return true if user.admin?
    return true if event.leader == user
    false
  end

  def self.can_participate?(user, event)
    return false if event.completed?
    return true if event.enrolling?
    false
  end
end
```

### 3. æ•°æ®éªŒè¯
```ruby
class ReadingEvent < ApplicationRecord
  validates :title, presence: true, length: { minimum: 5, maximum: 50 }
  validates :fee_amount, numericality: { greater_than_or_equal_to: 0 }
  validates :max_participants, numericality: { greater_than: 0, less_than_or_equal_to: 50 }

  validate :end_date_after_start_date

  private

  def end_date_after_start_date
    return if end_date.blank? || start_date.blank?

    if end_date < start_date
      errors.add(:end_date, "å¿…é¡»åœ¨å¼€å§‹æ—¥æœŸä¹‹å")
    end
  end
end
```

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### 1. æ•°æ®åº“ä¼˜åŒ–
```ruby
class ReadingEvent < ApplicationRecord
  # æ·»åŠ ç´¢å¼•
  has_many :reading_schedules, -> { order(:day_number) }
  has_many :enrollments, dependent: :destroy

  # é¢„åŠ è½½å…³è”
  def self.with_details
    includes(:leader, :enrollments => :user, :reading_schedules)
  end

  # æ‰¹é‡æ“ä½œ
  def self.batch_update_status(event_ids, status)
    where(id: event_ids).update_all(status: status)
  end
end
```

### 2. ç¼“å­˜ç­–ç•¥
```ruby
class EventCache
  def self.get_completion_rates(event_id)
    Rails.cache.fetch("event_#{event_id}_completion_rates", expires_in: 1.hour) do
      # è®¡ç®—å®Œæˆç‡é€»è¾‘
      calculate_completion_rates(event_id)
    end
  end

  def self.invalidate_event_cache(event_id)
    Rails.cache.delete("event_#{event_id}_completion_rates")
    Rails.cache.delete("event_#{event_id}_participants")
  end
end
```

### 3. å¼‚æ­¥å¤„ç†
```ruby
class EventCompletionJob < ApplicationJob
  queue_as :default

  def perform(event_id)
    event = ReadingEvent.find(event_id)

    # å¼‚æ­¥è®¡ç®—å®Œæˆç‡
    event.enrollments.find_each do |enrollment|
      completion_rate = CompletionRateCalculator.calculate_for_user(enrollment.user, event)
      enrollment.update!(completion_rate: completion_rate)
    end

    # ç”Ÿæˆè¯ä¹¦
    CertificateGenerator.generate_for_event(event)

    # å‘é€é€šçŸ¥
    EventObserver.notify(event, :completed)
  end
end
```

---

## ğŸ”„ APIè®¾è®¡åŸåˆ™

### 1. RESTfulè®¾è®¡
```ruby
# èµ„æºè·¯ç”±è®¾è®¡
resources :reading_events do
  member do
    post :enroll
    delete :enroll
    post :complete
    get :statistics
    get :participants
  end

  resources :reading_schedules do
    member do
      post :assign_leader
      get :daily_leading
    end
  end

  resources :check_ins do
    member do
      post :give_flower
    end
  end
end
```

### 2. ç»Ÿä¸€å“åº”æ ¼å¼
```ruby
class Api::V1::BaseController < ApplicationController
  private

  def render_success(data: nil, message: 'æ“ä½œæˆåŠŸ')
    render json: {
      success: true,
      message: message,
      data: data
    }
  end

  def render_error(message: 'æ“ä½œå¤±è´¥', errors: [], status: :unprocessable_entity)
    render json: {
      success: false,
      error: message,
      errors: errors
    }, status: status
  end
end
```

### 3. é”™è¯¯å¤„ç†
```ruby
class ApiError < StandardError
  attr_reader :code, :message, :status

  def initialize(code:, message:, status: :unprocessable_entity)
    @code = code
    @message = message
    @status = status
    super(message)
  end
end

class ValidationError < ApiError; end
class AuthorizationError < ApiError; end
class NotFoundError < ApiError; end
```

---

## ğŸ“ˆ ç›‘æ§å’Œæ—¥å¿—

### 1. åº”ç”¨ç›‘æ§
```ruby
class EventMetrics
  def self.track_event_creation(event)
    # è®°å½•æ´»åŠ¨åˆ›å»ºæŒ‡æ ‡
    Analytics.track('event_created', {
      event_id: event.id,
      fee_type: event.fee_type,
      activity_mode: event.activity_mode
    })
  end

  def self.track_participation(enrollment)
    # è®°å½•å‚ä¸æŒ‡æ ‡
    Analytics.track('user_participated', {
      event_id: enrollment.reading_event_id,
      user_id: enrollment.user_id
    })
  end
end
```

### 2. é”™è¯¯ç›‘æ§
```ruby
class ErrorReporter
  def self.report_error(exception, context = {})
    # å‘é€é”™è¯¯æŠ¥å‘Šåˆ°ç›‘æ§ç³»ç»Ÿ
    Raven.capture_exception(exception, {
      extra: context,
      tags: { component: 'reading_events' }
    })

    # è®°å½•åˆ°æ—¥å¿—
    Rails.logger.error "Reading Events Error: #{exception.message}"
    Rails.logger.error exception.backtrace.join("\n")
  end
end
```

### 3. ä¸šåŠ¡æ—¥å¿—
```ruby
class EventLogger
  def self.log_event_action(event, action, user, details = {})
    Rails.logger.info "Event Action: #{action}", {
      event_id: event.id,
      user_id: user.id,
      details: details,
      timestamp: Time.current
    }
  end
end
```

---

## ğŸš€ éƒ¨ç½²æ¶æ„

### DockeråŒ–éƒ¨ç½²
```dockerfile
FROM ruby:3.1-alpine

# å®‰è£…ä¾èµ–
COPY Gemfile Gemfile.lock ./
RUN bundle install

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# é¢„ç¼–è¯‘èµ„äº§
RUN bundle exec rails assets:precompile

# å¯åŠ¨åº”ç”¨
CMD ["rails", "server", "-b", "0.0.0.0", "-p", "3000"]
```

### ç¯å¢ƒé…ç½®
```ruby
# config/environments/production.rb
Rails.application.configure do
  # æ•°æ®åº“é…ç½®
  config.database_configuration = YAML.load_file('config/database.yml')

  # ç¼“å­˜é…ç½®
  config.cache_store = :redis_cache_store, {
    url: ENV['REDIS_URL'],
    namespace: 'reading_events'
  }

  # åå°ä»»åŠ¡
  config.active_job.queue_adapter = :sidekiq

  # æ—¥å¿—é…ç½®
  config.log_level = :info
  config.log_tags = [:request_id]
end
```

---

## ğŸ”§ å¼€å‘å·¥å…·

### 1. æµ‹è¯•æ¡†æ¶
```ruby
# spec/services/leader_assignment_service_spec.rb
RSpec.describe LeaderAssignmentService do
  describe '.assign_daily_leader' do
    let(:event) { create(:reading_event) }
    let(:schedule) { create(:reading_schedule, reading_event: event) }

    it 'assigns a leader to the schedule' do
      leader = LeaderAssignmentService.assign_daily_leader(event, schedule)

      expect(leader).to be_present
      expect(schedule.reload.daily_leader).to eq(leader)
    end

    it 'avoids recent leaders' do
      # æµ‹è¯•é¿å…æœ€è¿‘æ‹…ä»»é¢†è¯»çš„ç”¨æˆ·
    end
  end
end
```

### 2. å¼€å‘è„šæœ¬
```ruby
# lib/tasks/dev_tasks.rake
namespace :dev do
  task :setup_test_data => :environment do
    # åˆ›å»ºæµ‹è¯•æ•°æ®
    5.times { create(:reading_event, :with_schedules) }
    puts 'æµ‹è¯•æ•°æ®åˆ›å»ºå®Œæˆ'
  end

  task :simulate_activity => :environment do
    # æ¨¡æ‹Ÿæ´»åŠ¨è¿›è¡Œ
    EventSimulationService.run
  end
end
```

---

*æœ¬æ–‡æ¡£æœ€åæ›´æ–°: 2025-10-17*